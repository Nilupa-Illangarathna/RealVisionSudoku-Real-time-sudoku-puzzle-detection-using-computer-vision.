import cv2
import numpy as np

def initialize_video_capture(device_index=0):
    """
    Initialize video capture from the webcam.
    :param device_index: Index of the webcam device.
    :return: VideoCapture object.
    """
    return cv2.VideoCapture(device_index)

def image_processing(frame):
    """
    Apply image processing steps to detect edges in the frame.
    :param frame: Input frame.
    :return: Edges detected in the frame.
    """
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)
    return edges

def find_contours(edges):
    """
    Find contours in the edged image.
    :param edges: Edges detected in the frame.
    :return: Contours found in the edged image.
    """
    contours, _ = cv2.findContours(edges.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    return contours

def draw_contour(frame, contour):
    """
    Draw the contour on the original frame.
    :param frame: Original frame.
    :param contour: Contour to be drawn.
    """
    cv2.drawContours(frame, [contour], -1, (0, 255, 0), 1)

def sudoku_puzzle_verification(frame, approx):
    """
    Verify if a Sudoku puzzle is detected and perform further processing.
    :param frame: Original frame.
    :param approx: Approximated contour of the Sudoku puzzle.
    """
    if len(approx) == 4:
        pts_dst = np.array([[460, 460], [0, 460], [0, 0], [460, 0]], dtype=np.float32)
        matrix = cv2.getPerspectiveTransform(approx.reshape(4, 2).astype(np.float32), pts_dst)
        warped = cv2.warpPerspective(frame, matrix, (460, 460))
        warped = cv2.rotate(warped, cv2.ROTATE_90_COUNTERCLOCKWISE)
        warped = cv2.flip(warped, 1)
        warped_edges = cv2.Canny(warped, 50, 150)
        warped_lines = cv2.HoughLinesP(warped_edges, 1, np.pi / 180, 100, minLineLength=100, maxLineGap=100)
        if warped_lines is not None:
            for line in warped_lines:
                x1, y1, x2, y2 = line[0]
                cv2.line(warped, (x1, y1), (x2, y2), (0, 0, 255), 1)
            cv2.imshow('Warped Image', warped)

def display_frame(frame):
    """
    Display the resulting frame with detected contours and Hough lines.
    :param frame: Frame to be displayed.
    """
    cv2.imshow('Sudoku Recognition', frame)

def main():
    """
    Main function to capture video, process frames, and display results.
    """
    # Initialize video capture from the webcam
    cap = initialize_video_capture()

    while True:
        # Capture a frame from the webcam
        ret, frame = cap.read()

        # Apply image processing to detect edges in the frame
        edges = image_processing(frame)

        # Find contours in the edged image
        contours = find_contours(edges)

        # If contours are found
        if contours:
            # Sort contours by area and find the largest contour (presumed Sudoku puzzle)
            contours = sorted(contours, key=cv2.contourArea, reverse=True)[:1]

            # Approximate the contour to a polygon
            approx = cv2.approxPolyDP(contours[0], 0.02 * cv2.arcLength(contours[0], True), True)

            # Draw the contour on the original frame
            draw_contour(frame, approx)

            # If a Sudoku puzzle is detected (assuming 4 corners), proceed with further processing
            sudoku_puzzle_verification(frame, approx)

        # Display the resulting frame with detected contours and Hough lines
        display_frame(frame)

        # Break the loop when 'q' is pressed
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Release the webcam
    cap.release()

    # Close all OpenCV windows
    cv2.destroyAllWindows()


if __name__ == "__main__":
    main()
