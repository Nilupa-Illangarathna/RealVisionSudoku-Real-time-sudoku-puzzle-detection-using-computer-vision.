import cv2
import numpy as np
import os

# Initialize video capture from the webcam
cap = cv2.VideoCapture(0)

# Parameters for accumulating lines
frame_count = 0
all_lines = []

# Output folder for saving grid images
output_folder = "output"
os.makedirs(output_folder, exist_ok=True)

# Function to calculate the distance between two lines
def distance_between_lines(line1, line2):
    x1_1, y1_1, x2_1, y2_1 = line1
    x1_2, y1_2, x2_2, y2_2 = line2

    dist1 = np.sqrt((x1_1 - x1_2) ** 2 + (y1_1 - y1_2) ** 2)
    dist2 = np.sqrt((x2_1 - x2_2) ** 2 + (y2_1 - y2_2) ** 2)

    return min(dist1, dist2)

# Function to check if lines are almost parallel
def are_lines_almost_parallel(line1, line2):
    _, _, angle1, _ = cv2.fitLine(np.array([[line1[0], line1[1]], [line1[2], line1[3]]]), cv2.DIST_L2, 0, 0.01, 0.01)
    _, _, angle2, _ = cv2.fitLine(np.array([[line2[0], line2[1]], [line2[2], line2[3]]]), cv2.DIST_L2, 0, 0.01, 0.01)

    angle_diff = np.abs(angle1 - angle2)
    return angle_diff < np.pi / 10  # Adjust the threshold as needed

# Capture 150 frames for line accumulation
while frame_count < 10:
    # Capture frame-by-frame
    ret, frame = cap.read()

    # Image processing for Sudoku puzzle detection
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)

    # Draw hough lines on the frame
    lines = cv2.HoughLinesP(edges, 1, np.pi / 180, 100, minLineLength=100, maxLineGap=10)
    if lines is not None:
        all_lines.extend(lines)

    # Display the frame with detected contours and hough lines
    cv2.imshow('Line Accumulation', frame)

    # Increment frame count
    frame_count += 1

    # Break the loop when 'q' is pressed
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Merge and draw the accumulated lines on a black image
merged_lines_image = np.zeros_like(frame)
merged_lines = []

# Iterate through all lines and group nearby and almost parallel lines
for i, line1 in enumerate(all_lines):
    x1_1, y1_1, x2_1, y2_1 = line1[0]
    if i not in merged_lines:
        merged_line = [x1_1, y1_1, x2_1, y2_1]
        count = 1

        for j, line2 in enumerate(all_lines):
            if i != j and j not in merged_lines:
                x1_2, y1_2, x2_2, y2_2 = line2[0]

                # Check if lines are parallel and very near
                if (
                    are_lines_almost_parallel(line1[0], line2[0]) and
                    abs(distance_between_lines(line1[0], line2[0])) < 10
                ):
                    merged_line[0] += x1_2
                    merged_line[1] += y1_2
                    merged_line[2] += x2_2
                    merged_line[3] += y2_2
                    count += 1
                    merged_lines.append(j)

        # Calculate the average line
        merged_line = [int(coord / count) for coord in merged_line]
        merged_lines_image = cv2.line(merged_lines_image, (merged_line[0], merged_line[1]), (merged_line[2], merged_line[3]), (0, 0, 255), 2)

# Save the merged lines image to the output folder
cv2.imwrite(os.path.join(output_folder, "merged_lines.jpg"), merged_lines_image)

# Reset frame count and accumulated lines
frame_count = 0

# Continue with Sudoku recognition in real-time
while True:
    # Capture frame-by-frame
    ret, frame = cap.read()

    # Image processing for Sudoku puzzle detection
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)

    # Find contours in the edged image
    contours, _ = cv2.findContours(edges.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Check if any contours are found
    if contours:
        # Sort contours by area and find the largest contour (presumed Sudoku puzzle)
        contours = sorted(contours, key=cv2.contourArea, reverse=True)[:1]

        # Approximate the contour to a polygon
        epsilon = 0.02 * cv2.arcLength(contours[0], True)
        approx = cv2.approxPolyDP(contours[0], epsilon, True)

        # Draw the contour on the original frame
        cv2.drawContours(frame, [approx], -1, (0, 255, 0), 2)

        # If a Sudoku puzzle is detected (assuming 4 corners), proceed with digit identification
        if len(approx) == 4:
            # Define the destination points for the corrected projective transformation
            pts_dst = np.array([[460, 460], [0, 460], [0, 0], [460, 0]], dtype=np.float32)

            # Perform projective transformation
            matrix = cv2.getPerspectiveTransform(approx.reshape(4, 2).astype(np.float32), pts_dst)
            warped = cv2.warpPerspective(frame, matrix, (460, 460))

            # Perform rotation to correct the orientation (90 degrees counterclockwise)
            warped = cv2.rotate(warped, cv2.ROTATE_90_COUNTERCLOCKWISE)

            # Flip the warped image vertically (180 degrees)
            warped = cv2.flip(warped, 1)

            # Draw hough lines on the warped frame
            warped_edges = cv2.Canny(warped, 50, 150)
            warped_lines = cv2.HoughLinesP(warped_edges, 1, np.pi / 180, 100, minLineLength=100, maxLineGap=10)
            if warped_lines is not None:
                for line in warped_lines:
                    x1, y1, x2, y2 = line[0]
                    cv2.line(warped, (x1, y1), (x2, y2), (0, 0, 255), 1)

            # Display the warped image for digit identification (you can comment this line if not needed)
            cv2.imshow('Warped Image', warped)

    # Display the resulting frame with detected contours and hough lines
    cv2.imshow('Sudoku Recognition', frame)

    # Break the loop when 'q' is pressed
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the webcam and close all OpenCV windows
cap.release()
cv2.destroyAllWindows()
