import cv2
import numpy as np
import os

# Initialize video capture from the webcam
cap = cv2.VideoCapture(0)

# Parameters for accumulating lines
frame_count = 0
all_lines = []

# Output folder for saving grid images
output_folder = "output"
os.makedirs(output_folder, exist_ok=True)

# Capture 150 frames for line accumulation
while frame_count < 10:
    # Capture frame-by-frame
    ret, frame = cap.read()

    # Image processing for Sudoku puzzle detection
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)

    # Draw hough lines on the frame
    lines = cv2.HoughLinesP(edges, 1, np.pi / 180, 100, minLineLength=100, maxLineGap=10)
    if lines is not None:
        all_lines.extend(lines)

    # Display the frame with detected contours and hough lines
    cv2.imshow('Line Accumulation', frame)

    # Increment frame count
    frame_count += 1

    # Break the loop when 'q' is pressed
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Merge and draw the accumulated lines on a black image
merged_lines_image = np.zeros_like(frame)
for line in all_lines:
    x1, y1, x2, y2 = line[0]
    cv2.line(merged_lines_image, (x1, y1), (x2, y2), (0, 0, 255), 2)

# Save the merged lines image to the output folder
cv2.imwrite(os.path.join(output_folder, "merged_lines.jpg"), merged_lines_image)

# Reset frame count and accumulated lines
frame_count = 0
all_lines = []

# Continue with Sudoku recognition in real-time
while True:
    # Capture frame-by-frame
    ret, frame = cap.read()

    # Image processing for Sudoku puzzle detection
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)

    # Find contours in the edged image
    contours, _ = cv2.findContours(edges.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Check if any contours are found
    if contours:
        # Sort contours by area and find the largest contour (presumed Sudoku puzzle)
        contours = sorted(contours, key=cv2.contourArea, reverse=True)[:1]

        # Approximate the contour to a polygon
        epsilon = 0.02 * cv2.arcLength(contours[0], True)
        approx = cv2.approxPolyDP(contours[0], epsilon, True)

        # Draw the contour on the original frame
        cv2.drawContours(frame, [approx], -1, (0, 255, 0), 2)

        # If a Sudoku puzzle is detected (assuming 4 corners), proceed with digit identification
        if len(approx) == 4:
            # Define the destination points for the corrected projective transformation
            pts_dst = np.array([[460, 460], [0, 460], [0, 0], [460, 0]], dtype=np.float32)

            # Perform projective transformation
            matrix = cv2.getPerspectiveTransform(approx.reshape(4, 2).astype(np.float32), pts_dst)
            warped = cv2.warpPerspective(frame, matrix, (460, 460))

            # Perform rotation to correct the orientation (90 degrees counterclockwise)
            warped = cv2.rotate(warped, cv2.ROTATE_90_COUNTERCLOCKWISE)

            # Flip the warped image vertically (180 degrees)
            warped = cv2.flip(warped, 1)

            # Draw hough lines on the original frame
            # lines = cv2.HoughLinesP(edges, 1, np.pi / 180, 100, minLineLength=100, maxLineGap=10)
            # if lines is not None:
            #     for line in lines:
            #         x1, y1, x2, y2 = line[0]
            #         cv2.line(frame, (x1, y1), (x2, y2), (0, 0, 255), 2)

            # Draw hough lines on the warped frame
            warped_edges = cv2.Canny(warped, 50, 150)
            warped_lines = cv2.HoughLinesP(warped_edges, 1, np.pi / 180, 100, minLineLength=100, maxLineGap=10)
            if warped_lines is not None:
                for line in warped_lines:
                    x1, y1, x2, y2 = line[0]
                    cv2.line(warped, (x1, y1), (x2, y2), (0, 0, 255), 1)

            # Display the warped image for digit identification (you can comment this line if not needed)
            cv2.imshow('Warped Image', warped)

    # Display the resulting frame with detected contours and hough lines
    cv2.imshow('Sudoku Recognition', frame)

    # Break the loop when 'q' is pressed
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the webcam and close all OpenCV windows
cap.release()
cv2.destroyAllWindows()
